Diff in /Users/sbacha/disco-ecdsa/src/BlsSignatureTest.t.sol:
16  16   |         verified = verify(pub, _message, sig);
17  17   |     }
18  18   | 
19       |-    function decodePublicKey(bytes memory _pubKey)
20       |-        private
21       |-        pure
22       |-        returns (E2Point memory pubKey)
23       |-    {
    19   |+    function decodePublicKey(bytes memory _pubKey) private pure returns (E2Point memory pubKey) {
24  20   |         uint256[] memory output = new uint256[](4);
25  21   |         for (uint256 i = 32; i <= output.length * 32; i += 32) {
26  22   |             assembly {
--------------------------------------------------------------------------------
34  30   |         pubKey.y[1] = output[3];
35  31   |     }
36  32   | 
37       |-    function decodeSignature(bytes memory _sig)
38       |-        private
39       |-        pure
40       |-        returns (E1Point memory signature)
41       |-    {
    33   |+    function decodeSignature(bytes memory _sig) private pure returns (E1Point memory signature) {
42  34   |         uint256[] memory output = new uint256[](2);
43  35   |         for (uint256 i = 32; i <= output.length * 32; i += 32) {
44  36   |             assembly {
--------------------------------------------------------------------------------
50  42   |         signature.x = output[0];
51  43   |         signature.y = output[1];
52  44   |     }
53       |-}
    45   |+}

Diff in /Users/sbacha/disco-ecdsa/src/ECDSA_V01.sol:
4   4    | 
5   5    | pragma solidity ^0.8.0 <0.9.0;
6   6    | 
7        |-
8   7    | import "./Strings_V01.sol";
9   8    | 
10  9    | /**
--------------------------------------------------------------------------------
100 99   |      *
101 100  |      * _Available since v4.3._
102 101  |      */
103      |-    function tryRecover(
104      |-        bytes32 hash,
105      |-        bytes32 r,
106      |-        bytes32 vs
107      |-    ) internal pure returns (address, RecoverError) {
    102  |+    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {
108 103  |         bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
109 104  |         uint8 v = uint8((uint256(vs) >> 255) + 27);
110 105  |         return tryRecover(hash, v, r, s);
--------------------------------------------------------------------------------
115 110  |      *
116 111  |      * _Available since v4.2._
117 112  |      */
118      |-    function recover(
119      |-        bytes32 hash,
120      |-        bytes32 r,
121      |-        bytes32 vs
122      |-    ) internal pure returns (address) {
    113  |+    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {
123 114  |         (address recovered, RecoverError error) = tryRecover(hash, r, vs);
124 115  |         _throwError(error);
125 116  |         return recovered;
--------------------------------------------------------------------------------
131 122  |      *
132 123  |      * _Available since v4.3._
133 124  |      */
134      |-    function tryRecover(
135      |-        bytes32 hash,
136      |-        uint8 v,
137      |-        bytes32 r,
138      |-        bytes32 s
139      |-    ) internal pure returns (address, RecoverError) {
    125  |+    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {
140 126  |         // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
141 127  |         // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
142 128  |         // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most
--------------------------------------------------------------------------------
163 149  |      * @dev Overload of {ECDSA-recover} that receives the `v`,
164 150  |      * `r` and `s` signature fields separately.
165 151  |      */
166      |-    function recover(
167      |-        bytes32 hash,
168      |-        uint8 v,
169      |-        bytes32 r,
170      |-        bytes32 s
171      |-    ) internal pure returns (address) {
    152  |+    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
172 153  |         (address recovered, RecoverError error) = tryRecover(hash, v, r, s);
173 154  |         _throwError(error);
174 155  |         return recovered;

Diff in /Users/sbacha/disco-ecdsa/src/LibString_Assembly.sol:
67  67   |                 // Keep dividing temp until zero.
68  68   |                 temp := div(temp, 10)
69  69   | 
70       |-                 // prettier-ignore
    70   |+                // prettier-ignore
71  71   |                 if iszero(temp) { break }
72  72   |             }
73  73   | 

Diff in /Users/sbacha/disco-ecdsa/src/ECDSA_SignatureVerification.sol:
1   1    | // SPDX-License-Identifier: Apache-2.0
2   2    | pragma solidity >=0.8.4;
3   3    | 
4        |-
5   4    | /**
6   5    |  * Signature verification for ECDSA / KECCAK256 using secp256k1 curve.
7   6    |  */
--------------------------------------------------------------------------------
14  13   |      * @param _signature Signature to be verified.
15  14   |      *
16  15   |      */
17       |-    function verify(
18       |-        address _signer,
19       |-        bytes calldata _message,
20       |-        bytes calldata _signature
21       |-    ) internal pure returns (bool) {
    16   |+    function verify(address _signer, bytes calldata _message, bytes calldata _signature) internal pure returns (bool) {
22  17   |         // Check the signature length
23  18   |         if (_signature.length != 65) {
24  19   |             return false;
--------------------------------------------------------------------------------
49  44   |      * @param _sigV Component of the signature to be verified.
50  45   |      *
51  46   |      */
52       |-    function verifySigComponents(
53       |-        address _signer,
54       |-        bytes calldata _message,
55       |-        bytes32 _sigR,
56       |-        bytes32 _sigS,
57       |-        uint8 _sigV
58       |-    ) internal pure returns (bool) {
    47   |+    function verifySigComponents(address _signer, bytes calldata _message, bytes32 _sigR, bytes32 _sigS, uint8 _sigV)
    48   |+        internal
    49   |+        pure
    50   |+        returns (bool)
    51   |+    {
59  52   |         bytes32 digest = keccak256(_message);
60  53   | 
61  54   |         if (_sigV != 27 && _sigV != 28) {
--------------------------------------------------------------------------------
66  59   |             return _signer == ecrecover(digest, _sigV, _sigR, _sigS);
67  60   |         }
68  61   |     }
69       |-}
    62   |+}

Diff in /Users/sbacha/disco-ecdsa/src/EIP712_V01.sol:
1   1    | /// SPDX-License-Identifier: UPL or MIT
2   2    | 
3   3    | pragma solidity ^0.8.17 <0.9.0;
    4    |+
4   5    | import "./ECDSA_V01.sol";
5   6    | 
6   7    | /*
--------------------------------------------------------------------------------
59  60   |     constructor(string memory name, string memory version) {
60  61   |         bytes32 hashedName = keccak256(bytes(name));
61  62   |         bytes32 hashedVersion = keccak256(bytes(version));
62       |-        bytes32 typeHash = keccak256(
63       |-            "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
64       |-        );
    63   |+        bytes32 typeHash =
    64   |+            keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
65  65   |         _HASHED_NAME = hashedName;
66  66   |         _HASHED_VERSION = hashedVersion;
67  67   |         _CACHED_CHAIN_ID = block.chainid;
--------------------------------------------------------------------------------
81  81   |         }
82  82   |     }
83  83   | 
84       |-    function _buildDomainSeparator(
85       |-        bytes32 typeHash,
86       |-        bytes32 nameHash,
87       |-        bytes32 versionHash
88       |-    ) private view returns (bytes32) {
    84   |+    function _buildDomainSeparator(bytes32 typeHash, bytes32 nameHash, bytes32 versionHash)
    85   |+        private
    86   |+        view
    87   |+        returns (bytes32)
    88   |+    {
89  89   |         return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));
90  90   |     }
91  91   | 

Diff in /Users/sbacha/disco-ecdsa/src/PackedStringLib.sol:
48  48   |             // Read one word starting at the last byte of the length, so that the first
49  49   |             // byte of the packed string will be its length (left-padded) and the
50  50   |             // following 31 bytes will contain the string's body (right-padded).
51       |-            packedString := mul(
52       |-                mload(add(unpackedString, 31)),
53       |-                // If length is zero, the word after length will not be allocated for
54       |-                // the body and may contain dirty bits. We multiply the packed value by
55       |-                // length > 0 to ensure the body is null if the length is zero.
56       |-                iszero(iszero(length))
57       |-            )
    51   |+            packedString :=
    52   |+                mul(
    53   |+                    mload(add(unpackedString, 31)),
    54   |+                    // If length is zero, the word after length will not be allocated for
    55   |+                    // the body and may contain dirty bits. We multiply the packed value by
    56   |+                    // length > 0 to ensure the body is null if the length is zero.
    57   |+                    iszero(iszero(length))
    58   |+                )
58  59   |         }
59  60   |     }
60  61   | 

Diff in /Users/sbacha/disco-ecdsa/src/Strings_V01.sol:
3   3    | 
4   4    | pragma solidity ^0.8.0 <0.9.0;
5   5    | 
6        |-
7   6    | /**
8   7    |  * @dev String operations.
9   8    |  */
--------------------------------------------------------------------------------
20  19   | 
21  20   |             // compute log10(value), and add it to length
22  21   |             uint256 valueCopy = value;
23       |-            if (valueCopy >= 10**64) {
24       |-                valueCopy /= 10**64;
    22   |+            if (valueCopy >= 10 ** 64) {
    23   |+                valueCopy /= 10 ** 64;
25  24   |                 length += 64;
26  25   |             }
27       |-            if (valueCopy >= 10**32) {
28       |-                valueCopy /= 10**32;
    26   |+            if (valueCopy >= 10 ** 32) {
    27   |+                valueCopy /= 10 ** 32;
29  28   |                 length += 32;
30  29   |             }
31       |-            if (valueCopy >= 10**16) {
32       |-                valueCopy /= 10**16;
    30   |+            if (valueCopy >= 10 ** 16) {
    31   |+                valueCopy /= 10 ** 16;
33  32   |                 length += 16;
34  33   |             }
35       |-            if (valueCopy >= 10**8) {
36       |-                valueCopy /= 10**8;
    34   |+            if (valueCopy >= 10 ** 8) {
    35   |+                valueCopy /= 10 ** 8;
37  36   |                 length += 8;
38  37   |             }
39       |-            if (valueCopy >= 10**4) {
40       |-                valueCopy /= 10**4;
    38   |+            if (valueCopy >= 10 ** 4) {
    39   |+                valueCopy /= 10 ** 4;
41  40   |                 length += 4;
42  41   |             }
43       |-            if (valueCopy >= 10**2) {
44       |-                valueCopy /= 10**2;
    42   |+            if (valueCopy >= 10 ** 2) {
    43   |+                valueCopy /= 10 ** 2;
45  44   |                 length += 2;
46  45   |             }
47       |-            if (valueCopy >= 10**1) {
    46   |+            if (valueCopy >= 10 ** 1) {
48  47   |                 length += 1;
49  48   |             }
50  49   |             // now, length is log10(value) + 1
--------------------------------------------------------------------------------
124 123  |     function toHexString(address addr) internal pure returns (string memory) {
125 124  |         return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
126 125  |     }
127      |-}
    126  |+}

Diff in /Users/sbacha/disco-ecdsa/src/SignatureEncoding.sol:
29  29   |     /**
30  30   |      *
31  31   |      *  ✓ decodeSignature
32       |-     * 
    32   |+     *
33  33   |      *  Decode a signature blob.
34  34   |      *
35  35   |      * @param _signatures Encoded signatures.
36  36   |      * @return Signture object.
37       |-     * 
    37   |+     *
38  38   |      */
39       |-    function decodeSignature(bytes calldata _signatures)
40       |-        internal
41       |-        pure
42       |-        returns (Signatures memory)
43       |-    {
    39   |+    function decodeSignature(bytes calldata _signatures) internal pure returns (Signatures memory) {
44  40   |         (
45  41   |             ,
46       |-        /* Skip offset of dynamic type */
    42   |+            /* Skip offset of dynamic type */
47  43   |             uint256 sigType
48  44   |         ) = abi.decode(_signatures, (uint256, uint256));
49  45   |         require(sigType == ECDSA_SIGNATURE, "Signature unknown type");

Diff in /Users/sbacha/disco-ecdsa/src/ECDSA_SignatureTest.t.sol:
4   4    | import "./ECDSA_SignatureVerification.sol";
5   5    | 
6   6    | contract EcdsaSignatureTest is EcdsaSignatureVerification {
7        |-    function verify2(
8        |-        address _signer,
9        |-        bytes calldata _message,
10       |-        bytes calldata _signature
11       |-    ) external pure returns (bool) {
    7    |+    function verify2(address _signer, bytes calldata _message, bytes calldata _signature)
    8    |+        external
    9    |+        pure
    10   |+        returns (bool)
    11   |+    {
12  12   |         return verify(_signer, _message, _signature);
13  13   |     }
14  14   | 
15       |-    function verifySigComponents2(
16       |-        address _signer,
17       |-        bytes calldata _message,
18       |-        bytes32 _sigR,
19       |-        bytes32 _sigS,
20       |-        uint8 _sigV
21       |-    ) external pure returns (bool) {
    15   |+    function verifySigComponents2(address _signer, bytes calldata _message, bytes32 _sigR, bytes32 _sigS, uint8 _sigV)
    16   |+        external
    17   |+        pure
    18   |+        returns (bool)
    19   |+    {
22  20   |         return verifySigComponents(_signer, _message, _sigR, _sigS, _sigV);
23  21   |     }
24       |-}
    22   |+}

Diff in /Users/sbacha/disco-ecdsa/src/BlsSignatureVerification.sol:
30  30   |      * @param _signature Signature over the message.
31  31   |      * @return True if the message was correctly signed.
32  32   |      */
33       |-    function verify(
34       |-        E2Point memory _publicKey,
35       |-        bytes memory _message,
36       |-        E1Point memory _signature
37       |-    ) internal view returns (bool) {
    33   |+    function verify(E2Point memory _publicKey, bytes memory _message, E1Point memory _signature)
    34   |+        internal
    35   |+        view
    36   |+        returns (bool)
    37   |+    {
38  38   |         E1Point[] memory e1points = new E1Point[](2);
39  39   |         E2Point[] memory e2points = new E2Point[](2);
40  40   |         e1points[0] = negate(_signature);
--------------------------------------------------------------------------------
55  55   |      * @return The generator of E2.
56  56   |      */
57  57   |     function G2() private pure returns (E2Point memory) {
58       |-        return
59       |-            E2Point({
60       |-                x: [
61       |-                    11559732032986387107991004021392285783925812861821192530917403151452391805634,
62       |-                    10857046999023057135944570762232829481370756359578518086990519993285655852781
63       |-                ],
64       |-                y: [
65       |-                    4082367875863433681332203403145435568316851327593401208105741076214120093531,
66       |-                    8495653923123431417604973247489272438418190587263600148770280649306958101930
67       |-                ]
68       |-            });
    58   |+        return E2Point({
    59   |+            x: [
    60   |+                11559732032986387107991004021392285783925812861821192530917403151452391805634,
    61   |+                10857046999023057135944570762232829481370756359578518086990519993285655852781
    62   |+            ],
    63   |+            y: [
    64   |+                4082367875863433681332203403145435568316851327593401208105741076214120093531,
    65   |+                8495653923123431417604973247489272438418190587263600148770280649306958101930
    66   |+            ]
    67   |+        });
69  68   |     }
70  69   | 
71  70   |     /**
--------------------------------------------------------------------------------
74  73   |      * @param _data Value to derive a point from.
75  74   |      * @return a point on the E1 curve.
76  75   |      */
77       |-    function hashToCurveE1(bytes memory _data)
78       |-        private
79       |-        view
80       |-        returns (E1Point memory)
81       |-    {
    76   |+    function hashToCurveE1(bytes memory _data) private view returns (E1Point memory) {
82  77   |         uint256 digest = uint256(keccak256(_data));
83  78   | 
84  79   |         uint8 ctr = 0;
--------------------------------------------------------------------------------
97  92   | 
98  93   |             // bump counter for next round, if necessary
99  94   |             ctr++;
100      |-            require(
101      |-                ctr < MAX_ATTEMPTS_AT_HASH_TO_CURVE,
102      |-                "Failed to map to point"
103      |-            );
    95   |+            require(ctr < MAX_ATTEMPTS_AT_HASH_TO_CURVE, "Failed to map to point");
104 96   |         }
105 97   |         return (p);
106 98   |     }
--------------------------------------------------------------------------------
112 104  |      * @param _point Point to negate.
113 105  |      * @return The negated point.
114 106  |      */
115      |-    function negate(E1Point memory _point)
116      |-        private
117      |-        pure
118      |-        returns (E1Point memory)
119      |-    {
    107  |+    function negate(E1Point memory _point) private pure returns (E1Point memory) {
120 108  |         // Field Modulus.
121 109  |         uint256 q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;
122 110  |         if (isAtInfinity(_point)) {
--------------------------------------------------------------------------------
132 120  |      * @param _e2points List of points in E2.
133 121  |      * @return True if pairing check succeeds.
134 122  |      */
135      |-    function pairing(E1Point[] memory _e1points, E2Point[] memory _e2points)
136      |-        private
137      |-        view
138      |-        returns (bool)
139      |-    {
    123  |+    function pairing(E1Point[] memory _e1points, E2Point[] memory _e2points) private view returns (bool) {
140 124  |         require(_e1points.length == _e2points.length, "Point count mismatch.");
141 125  | 
142 126  |         uint256 elements = _e1points.length;
--------------------------------------------------------------------------------
158 142  |         assembly {
159 143  |             // Start at memory offset 0x20 rather than 0 as input is a variable length array.
160 144  |             // Location 0 is the length field.
161      |-            success := staticcall(
162      |-                sub(gas(), 2000),
163      |-                8,
164      |-                add(input, 0x20),
165      |-                mul(inputSize, 0x20),
166      |-                out,
167      |-                0x20
168      |-            )
    145  |+            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)
169 146  |         }
170 147  |         // The pairing operation will fail if the input data isn't the correct size (this won't happen
171 148  |         // given the code above), or if one of the points isn't on the curve.
--------------------------------------------------------------------------------
180 157  |      * @param _scalar Scalar to multiply.
181 158  |      * @return The resulting E1 point.
182 159  |      */
183      |-    function curveMul(E1Point memory _point, uint256 _scalar)
184      |-        private
185      |-        view
186      |-        returns (E1Point memory)
187      |-    {
    160  |+    function curveMul(E1Point memory _point, uint256 _scalar) private view returns (E1Point memory) {
188 161  |         uint256[3] memory input;
189 162  |         input[0] = _point.x;
190 163  |         input[1] = _point.y;
--------------------------------------------------------------------------------
193 166  |         bool success;
194 167  |         E1Point memory result;
195 168  |         assembly {
196      |-            success := staticcall(
197      |-                sub(gas(), 2000),
198      |-                7,
199      |-                input,
200      |-                0x60,
201      |-                result,
202      |-                0x40
203      |-            )
    169  |+            success := staticcall(sub(gas(), 2000), 7, input, 0x60, result, 0x40)
204 170  |         }
205 171  |         require(success, "Point multiplication failed.");
206 172  |         return result;
--------------------------------------------------------------------------------
215 181  |     function isAtInfinity(E1Point memory _point) private pure returns (bool) {
216 182  |         return (_point.x == 0 && _point.y == 0);
217 183  |     }
218      |-}
    184  |+}

Diff in /Users/sbacha/disco-ecdsa/test/DSTestPlus.sol:
92  92   |         b ? assertTrue(a) : assertFalse(a);
93  93   |     }
94  94   | 
95       |-    function assertApproxEq(
96       |-        uint256 a,
97       |-        uint256 b,
98       |-        uint256 maxDelta
99       |-    ) internal virtual {
    95   |+    function assertApproxEq(uint256 a, uint256 b, uint256 maxDelta) internal virtual {
100 96   |         uint256 delta = a > b ? a - b : b - a;
101 97   | 
102 98   |         if (delta > maxDelta) {
--------------------------------------------------------------------------------
145 141  |         }
146 142  |     }
147 143  | 
148      |-    function bound(
149      |-        uint256 x,
150      |-        uint256 min,
151      |-        uint256 max
152      |-    ) internal virtual returns (uint256 result) {
    144  |+    function bound(uint256 x, uint256 min, uint256 max) internal virtual returns (uint256 result) {
153 145  |         require(max >= min, "MAX_LESS_THAN_MIN");
154 146  | 
155 147  |         uint256 size = max - min;
156 148  | 
157      |-        if (size == 0) result = min;
158      |-        else if (size == type(uint256).max) result = x;
159      |-        else {
    149  |+        if (size == 0) {
    150  |+            result = min;
    151  |+        } else if (size == type(uint256).max) {
    152  |+            result = x;
    153  |+        } else {
160 154  |             ++size; // Make max inclusive.
161 155  |             uint256 mod = x % size;
162 156  |             result = min + mod;
--------------------------------------------------------------------------------
165 159  |         emit log_named_uint("Bound Result", result);
166 160  |     }
167 161  | 
168      |-    function min3(
169      |-        uint256 a,
170      |-        uint256 b,
171      |-        uint256 c
172      |-    ) internal pure returns (uint256) {
    162  |+    function min3(uint256 a, uint256 b, uint256 c) internal pure returns (uint256) {
173 163  |         return a > b ? (b > c ? c : b) : (a > c ? c : a);
174 164  |     }
175 165  | 

Diff in /Users/sbacha/disco-ecdsa/test/ECDSA.sol:
88  88   |                 ptr := sub(ptr, 1)
89  89   |                 mstore8(ptr, add(48, mod(temp, 10)))
90  90   |                 temp := div(temp, 10)
91       |-            } temp {
92       |-                temp := div(temp, 10)
93       |-            } {
    91   |+            } temp { temp := div(temp, 10) } {
94  92   |                 ptr := sub(ptr, 1)
95  93   |                 mstore8(ptr, add(48, mod(temp, 10)))
96  94   |             }

Diff in /Users/sbacha/disco-ecdsa/test/SignatureChecker.sol:
27  27   |             return true;
28  28   |         }
29  29   | 
30       |-        (bool success, bytes memory result) = signer.staticcall(
31       |-            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)
    30   |+        (bool success, bytes memory result) =
    31   |+            signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature));
    32   |+        return (
    33   |+            success && result.length == 32
    34   |+                && abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector)
32  35   |         );
33       |-        return (success &&
34       |-            result.length == 32 &&
35       |-            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));
36  36   |     }
37  37   | }

Diff in /Users/sbacha/disco-ecdsa/test/ECDSA.t.sol:
26  26   | 
27  27   |     function testRecoverWithInvalidLongSignature() public {
28  28   |         // prettier-ignore
29       |-        bytes memory signature = hex"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789";
    29   |+        bytes memory signature =
    30   |+            hex"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789";
30  31   |         assertTrue(this.recover(TEST_MESSAGE, signature) == address(0));
31  32   |     }
32  33   | 
33  34   |     function testRecoverWithValidSignature() public {
34  35   |         // prettier-ignore
35       |-        bytes memory signature = hex"8688e590483917863a35ef230c0f839be8418aa4ee765228eddfcea7fe2652815db01c2c84b0ec746e1b74d97475c599b3d3419fa7181b4e01de62c02b721aea1b";
    36   |+        bytes memory signature =
    37   |+            hex"8688e590483917863a35ef230c0f839be8418aa4ee765228eddfcea7fe2652815db01c2c84b0ec746e1b74d97475c599b3d3419fa7181b4e01de62c02b721aea1b";
36  38   |         assertTrue(this.recover(TEST_MESSAGE.toEthSignedMessageHash(), signature) == SIGNER);
37  39   |     }
38  40   | 
39  41   |     function testRecoverWithWrongSigner() public {
40  42   |         // prettier-ignore
41       |-        bytes memory signature = hex"8688e590483917863a35ef230c0f839be8418aa4ee765228eddfcea7fe2652815db01c2c84b0ec746e1b74d97475c599b3d3419fa7181b4e01de62c02b721aea1b";
    43   |+        bytes memory signature =
    44   |+            hex"8688e590483917863a35ef230c0f839be8418aa4ee765228eddfcea7fe2652815db01c2c84b0ec746e1b74d97475c599b3d3419fa7181b4e01de62c02b721aea1b";
42  45   |         assertTrue(this.recover(WRONG_MESSAGE.toEthSignedMessageHash(), signature) != SIGNER);
43  46   |     }
44  47   | 
45  48   |     function testRecoverWithInvalidSignature() public {
46  49   |         // prettier-ignore
47       |-        bytes memory signature = hex"332ce75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e01c";
    50   |+        bytes memory signature =
    51   |+            hex"332ce75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e01c";
48  52   |         assertTrue(this.recover(TEST_MESSAGE.toEthSignedMessageHash(), signature) != SIGNER);
49  53   |     }
50  54   | 
51  55   |     function testRecoverWithV0SignatureWithVersion00() public {
52  56   |         // prettier-ignore
53       |-        bytes memory signature = hex"5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be89200";
    57   |+        bytes memory signature =
    58   |+            hex"5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be89200";
54  59   |         assertTrue(this.recover(TEST_MESSAGE, signature) == address(0));
55  60   |     }
56  61   | 
57  62   |     function testRecoverWithV0SignatureWithVersion27() public {
58  63   |         // prettier-ignore
59       |-        bytes memory signature = hex"5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be8921b";
    64   |+        bytes memory signature =
    65   |+            hex"5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be8921b";
60  66   |         assertTrue(this.recover(TEST_MESSAGE, signature) == V0_SIGNER);
61  67   |     }
62  68   | 
63  69   |     function testRecoverWithV0SignatureWithWrongVersion() public {
64  70   |         // prettier-ignore
65       |-        bytes memory signature = hex"5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be89202";
    71   |+        bytes memory signature =
    72   |+            hex"5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be89202";
66  73   |         assertTrue(this.recover(TEST_MESSAGE, signature) == address(0));
67  74   |     }
68  75   | 
69  76   |     function testRecoverWithV0SignatureWithShortEIP2098Format() public {
70  77   |         // prettier-ignore
71       |-        bytes memory signature = hex"5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be892";
    78   |+        bytes memory signature =
    79   |+            hex"5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be892";
72  80   |         assertTrue(this.recover(TEST_MESSAGE, signature) == V0_SIGNER);
73  81   |     }
74  82   | 
75  83   |     function testRecoverWithV1SignatureWithVersion01() public {
76  84   |         // prettier-ignore
77       |-        bytes memory signature = hex"331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e001";
    85   |+        bytes memory signature =
    86   |+            hex"331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e001";
78  87   |         assertTrue(this.recover(TEST_MESSAGE, signature) == address(0));
79  88   |     }
80  89   | 
81  90   |     function testRecoverWithV1SignatureWithVersion28() public {
82  91   |         // prettier-ignore
83       |-        bytes memory signature = hex"331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e01c";
    92   |+        bytes memory signature =
    93   |+            hex"331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e01c";
84  94   |         assertTrue(this.recover(TEST_MESSAGE, signature) == V1_SIGNER);
85  95   |     }
86  96   | 
87  97   |     function testRecoverWithV1SignatureWithWrongVersion() public {
88  98   |         // prettier-ignore
89       |-        bytes memory signature = hex"331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e002";
    99   |+        bytes memory signature =
    100  |+            hex"331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e002";
90  101  |         assertTrue(this.recover(TEST_MESSAGE, signature) == address(0));
91  102  |     }
92  103  | 
93  104  |     function testRecoverWithV1SignatureWithShortEIP2098Format() public {
94  105  |         // prettier-ignore
95       |-        bytes memory signature = hex"331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feffc8e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e0";
    106  |+        bytes memory signature =
    107  |+            hex"331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feffc8e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e0";
96  108  |         assertTrue(this.recover(TEST_MESSAGE, signature) == V1_SIGNER);
97  109  |     }
98  110  | 
99  111  |     function testBytes32ToEthSignedMessageHash() public {
100 112  |         // prettier-ignore
101      |-        assertTrue(TEST_MESSAGE.toEthSignedMessageHash() == bytes32(0x7d768af957ef8cbf6219a37e743d5546d911dae3e46449d8a5810522db2ef65e));
    113  |+        assertTrue(
    114  |+            TEST_MESSAGE.toEthSignedMessageHash()
    115  |+                == bytes32(0x7d768af957ef8cbf6219a37e743d5546d911dae3e46449d8a5810522db2ef65e)
    116  |+        );
102 117  |     }
103 118  | 
104 119  |     function testBytesToEthSignedMessageHashShort() public {
105 120  |         bytes memory message = hex"61626364";
106 121  |         // prettier-ignore
107      |-        assertTrue(message.toEthSignedMessageHash() == bytes32(0xefd0b51a9c4e5f3449f4eeacb195bf48659fbc00d2f4001bf4c088ba0779fb33));
    122  |+        assertTrue(
    123  |+            message.toEthSignedMessageHash()
    124  |+                == bytes32(0xefd0b51a9c4e5f3449f4eeacb195bf48659fbc00d2f4001bf4c088ba0779fb33)
    125  |+        );
108 126  |     }
109 127  | 
110 128  |     function testBytesToEthSignedMessageHashEmpty() public {
111 129  |         bytes memory message = hex"";
112 130  |         // prettier-ignore
113      |-        assertTrue(message.toEthSignedMessageHash() == bytes32(0x5f35dce98ba4fba25530a026ed80b2cecdaa31091ba4958b99b52ea1d068adad));
    131  |+        assertTrue(
    132  |+            message.toEthSignedMessageHash()
    133  |+                == bytes32(0x5f35dce98ba4fba25530a026ed80b2cecdaa31091ba4958b99b52ea1d068adad)
    134  |+        );
114 135  |     }
115 136  | 
116 137  |     function testBytesToEthSignedMessageHashEmptyLong() public {
117 138  |         // prettier-ignore
118      |-        bytes memory message = hex"4142434445464748494a4b4c4d4e4f505152535455565758595a6162636465666768696a6b6c6d6e6f707172737475767778797a3031323334353637383921402324255e262a28292d3d5b5d7b7d";
    139  |+        bytes memory message =
    140  |+            hex"4142434445464748494a4b4c4d4e4f505152535455565758595a6162636465666768696a6b6c6d6e6f707172737475767778797a3031323334353637383921402324255e262a28292d3d5b5d7b7d";
119 141  |         // prettier-ignore
120      |-        assertTrue(message.toEthSignedMessageHash() == bytes32(0xa46dbedd405cff161b6e80c17c8567597621d9f4c087204201097cb34448e71b));
    142  |+        assertTrue(
    143  |+            message.toEthSignedMessageHash()
    144  |+                == bytes32(0xa46dbedd405cff161b6e80c17c8567597621d9f4c087204201097cb34448e71b)
    145  |+        );
121 146  |     }
122 147  | 
123 148  |     function recover(bytes32 hash, bytes calldata signature) external view returns (address) {

Diff in /Users/sbacha/disco-ecdsa/test/Hevm.sol:
15  15   |     function load(address, bytes32) external returns (bytes32);
16  16   | 
17  17   |     /// @notice Stores a value to an address' storage slot.
18       |-    function store(
19       |-        address,
20       |-        bytes32,
21       |-        bytes32
22       |-    ) external;
    18   |+    function store(address, bytes32, bytes32) external;
23  19   | 
24  20   |     /// @notice Signs a digest with a private key, returns v r s.
25       |-    function sign(uint256, bytes32)
26       |-        external
27       |-        returns (
28       |-            uint8,
29       |-            bytes32,
30       |-            bytes32
31       |-        );
    21   |+    function sign(uint256, bytes32) external returns (uint8, bytes32, bytes32);
32  22   | 
33  23   |     /// @notice Gets address for a given private key.
34  24   |     function addr(uint256) external returns (address);
--------------------------------------------------------------------------------
73  63   |     /// @notice Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).
74  64   |     /// @notice Call this function, then emit an event, then call a function. Internally after the call, we check
75  65   |     /// if logs were emitted in the expected order with the expected topics and data as specified by the booleans.
76       |-    function expectEmit(
77       |-        bool,
78       |-        bool,
79       |-        bool,
80       |-        bool
81       |-    ) external;
    66   |+    function expectEmit(bool, bool, bool, bool) external;
82  67   | 
83  68   |     /// @notice Mocks the behavior of a contract call, setting the input and output for a function.
84  69   |     /// @notice Calldata can either be strict or a partial match, e.g. if only passed
85  70   |     /// a selector to the expected calldata, then the entire function will be mocked.
86       |-    function mockCall(
87       |-        address,
88       |-        bytes calldata,
89       |-        bytes calldata
90       |-    ) external;
    71   |+    function mockCall(address, bytes calldata, bytes calldata) external;
91  72   | 
92  73   |     /// @notice Clears all mocked calls.
93  74   |     function clearMockedCalls() external;
